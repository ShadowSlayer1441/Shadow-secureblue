# Toggle the cups service on/off
toggle-cups:
    #! /bin/run0 /bin/bash
    if systemctl is-enabled --quiet cups; then
      firewall-cmd --permanent --remove-port=631/tcp
      firewall-cmd --permanent --remove-port=631/udp 
      firewall-cmd --reload 
      systemctl mask cups
      systemctl disable cups
      systemctl stop cups
      systemctl daemon-reload
      echo "Cups disabled."
    else
      firewall-cmd --permanent --add-port=631/tcp
      firewall-cmd --permanent --add-port=631/udp 
      firewall-cmd --reload 
      systemctl unmask cups
      systemctl enable cups
      systemctl start cups
      systemctl daemon-reload
      echo "Cups enabled."
    fi

# Toggle bluetooth kernel modules on/off (requires reboot)
toggle-bluetooth-modules:
    #! /bin/run0 /bin/bash
    BLUE_MOD_FILE="/etc/modprobe.d/99-bluetooth.conf"
    if test -e $BLUE_MOD_FILE; then
      rm -f $BLUE_MOD_FILE
      echo "Bluetooth kernel modules disabled. Reboot to take effect."
    else
      sh -c 'echo "install bluetooth /sbin/modprobe --ignore-install bluetooth" >> "$1"' _ "$BLUE_MOD_FILE"
      sh -c 'echo "install btusb /sbin/modprobe --ignore-install btusb" >> "$1"' _ "$BLUE_MOD_FILE"
      chmod 644 $BLUE_MOD_FILE
      echo "Bluetooth kernel modules enabled. Reboot to take effect."
    fi

# Toggle GHNS (KDE Get New Stuff)
toggle-ghns:
    #! /bin/run0 /bin/bash
    KDE_GLOBALS_FILE="/etc/xdg/kdeglobals"
    if test -e $KDE_GLOBALS_FILE; then
      if grep -q "ghns=false" "$KDE_GLOBALS_FILE"; then
        sed -i "s/ghns=false/ghns=true/" "$KDE_GLOBALS_FILE"
        echo "GHNS enabled."
      elif grep -q "ghns=true" "$KDE_GLOBALS_FILE"; then
        sed -i "s/ghns=true/ghns=false/" "$KDE_GLOBALS_FILE"
        echo "GHNS disabled."
      else 
        echo "The kdeglobals file is missing the ghns toggle."
      fi
    else
      echo "No kdeglobals file found. Are you on kinoite?"
    fi

# enable a kernel module that is disabled by modprobe.d (requires restart)
override-enable-module mod_name:
    #! /bin/run0 /bin/bash
    MOD_NAME="{{ mod_name }}"
    MOD_FILE="/etc/modprobe.d/99-$MOD_NAME.conf"
    if test -e $MOD_FILE; then
      echo "$MOD_NAME module is already enabled."
    else
      sh -c 'echo "install $1 /sbin/modprobe --ignore-install $1" >> "$2"' _ "$MOD_NAME" "$MOD_FILE" 
      chmod 644 $MOD_FILE
      echo "Override created to enable $MOD_NAME module. Reboot to take effect."
    fi

# reset the override by `just override-enable-module`, i.e. disable the module again (requires restart)
override-reset-module mod_name:
    #! /bin/run0 /bin/bash
    MOD_NAME="{{ mod_name }}"
    MOD_FILE="/etc/modprobe.d/99-$MOD_NAME.conf"
    if test -e $MOD_FILE; then
      rm -f $MOD_FILE
      echo "The override for $MOD_NAME module has been reset. Reboot to take effect."
    else
      echo "No override found for $MOD_NAME module."
    fi

# Toggle debug mode (requires restart)
toggle-debug-mode:
    #! /bin/run0 /bin/bash
    if test -e /etc/sysctl.d/99-enable-coredump.conf; then
        cp /usr/etc/security/limits.d/60-disable-coredump.conf /etc/security/limits.d/60-disable-coredump.conf
        cp /usr/etc/systemd/system.conf.d/60-disable-coredump.conf /etc/systemd/system.conf.d/60-disable-coredump.conf
        cp /usr/etc/systemd/user.conf.d/60-disable-coredump.conf /etc/systemd/user.conf.d/60-disable-coredump.conf
        rm /etc/sysctl.d/99-enable-coredump.conf
        echo "Debug mode disabled."
    else
        rm /etc/security/limits.d/60-disable-coredump.conf
        rm /etc/systemd/system.conf.d/60-disable-coredump.conf
        rm /etc/systemd/user.conf.d/60-disable-coredump.conf
        echo "kernel.core_pattern = |/usr/lib/systemd/systemd-coredump %P %u %g %s %t %c %h" >/etc/sysctl.d/99-enable-coredump.conf
        echo "Debug mode enabled."
        if [[ $(</proc/sys/kernel/yama/ptrace_scope) != 1 ]]; then
            echo "ptrace is restricted in this session. Some debuggers may not work as intended. Use ujust toggle-ptrace-scope to manage ptrace."
        fi
    fi

alias toggle-ptrace-scope := toggle-anticheat-support

# Toggle anticheat support by changing ptrace scope (requires restart)
toggle-anticheat-support:
    #! /bin/run0 /bin/bash
    SYSCTL_HARDENING_FILE="/etc/sysctl.d/60-hardening.conf"
    if grep -q "kernel.yama.ptrace_scope = 3" "$SYSCTL_HARDENING_FILE"; then
        sed -i "s/kernel.yama.ptrace_scope = 3/kernel.yama.ptrace_scope = 1/" "$SYSCTL_HARDENING_FILE"
        echo "Anticheat support enabled. ptrace_scope set to 1."
    elif grep -q "kernel.yama.ptrace_scope = 1" "$SYSCTL_HARDENING_FILE"; then
        sed -i "s/kernel.yama.ptrace_scope = 1/kernel.yama.ptrace_scope = 3/" "$SYSCTL_HARDENING_FILE"
        echo "Anticheat support disabled. ptrace_scope set back to 3."
    else 
        echo "The sysctl hardening file is missing the ptrace_scope setting."
    fi

# Toggle Gnome JIT JavaScript for GJS and WebkitGTK (requires session restart)
toggle-gnome-jit-js:
    #! /bin/run0 /bin/bash
    ENV_FILE="/etc/profile.d/gnome-disable-jit.sh"
    if test -e $ENV_FILE; then
        rm -f $ENV_FILE
        echo "JIT JavaScript for Gnome and WebkitGTK has been enabled."
    else
        cp /usr$ENV_FILE $ENV_FILE
        chmod 644 $ENV_FILE
        echo "JIT JavaScript for Gnome and WebkitGTK has been disabled."
    fi

# Toggle support for using GNOME user extensions
toggle-gnome-extensions:
    #!/usr/bin/bash
    GSETTING="$(gsettings get org.gnome.shell allow-extension-installation)"
    if [[ "${GSETTING}" == "false" ]]; then
      gsettings set org.gnome.shell allow-extension-installation true
      echo "Support for GNOME user extensions have been enabled"
    else
      gsettings reset org.gnome.shell allow-extension-installation
      echo "Support for GNOME user extensions have been disabled"
    fi

# Toggle Xwayland support
toggle-xwayland ACTION="prompt":
    #! /bin/run0 /bin/bash
    source /usr/lib/ujust/ujust.sh
    OPTION={{ ACTION }}
    if [ "$OPTION" == "prompt" ]; then
      IMAGE="$(rpm-ostree status | grep '●')"
      if [ -n "$(echo $IMAGE | grep 'silverblue')" ] ; then
          OPTION=gnome
      elif [ -n "$(echo $IMAGE | grep 'kinoite')" ] ; then
          OPTION=plasma
      elif [ -n "$(echo $IMAGE | grep 'sericea')" ] || [ -n "$(echo $IMAGE | grep 'sway')" ] ; then
          OPTION=sway
      else
        echo "${bold}Toggling Xwayland (requires logout)${normal}"
        echo 'For which DE/WM do you want to toggle Xwayland?'
        OPTION=$(ugum choose "GNOME" "KDE Plasma" "Sway")
      fi
    elif [ "$OPTION" == "help" ]; then
      echo "Usage: ujust toggle-xwayland <option>"
      echo "  <option>: Specify the quick option - 'gnome', 'plasma', or 'sway'"
      echo "  Use 'gnome' to Toggle Xwayland for GNOME."
      echo "  Use 'plasma' to Toggle Xwayland for KDE Plasma."
      echo "  Use 'sway' to Toggle Xwayland for Sway."
      exit 0
    fi
    if [ "${OPTION,,}" == "gnome" ]; then
      GNOME_XWAYLAND_FILE="/etc/systemd/user/org.gnome.Shell@wayland.service.d/override.conf"
      if test -e $GNOME_XWAYLAND_FILE; then
        rm -f $GNOME_XWAYLAND_FILE
        echo "Xwayland for GNOME has been enabled."
      else
        cp /usr$GNOME_XWAYLAND_FILE $GNOME_XWAYLAND_FILE
        chmod 644 $GNOME_XWAYLAND_FILE
        echo "Xwayland for GNOME has been disabled."
      fi
    elif [ "$OPTION" == "KDE Plasma" ] || [ "${OPTION,,}" == "plasma" ]; then
      PLASMA_XWAYLAND_FILE="/etc/systemd/user/plasma-kwin_wayland.service.d/override.conf"
      if test -e $PLASMA_XWAYLAND_FILE; then
        rm -f $PLASMA_XWAYLAND_FILE
        echo "Xwayland for KDE Plasma has been enabled."
      else
        cp /usr$PLASMA_XWAYLAND_FILE $PLASMA_XWAYLAND_FILE
        chmod 644 $PLASMA_XWAYLAND_FILE
        echo "Xwayland for KDE Plasma has been disabled."
      fi
    elif [ "${OPTION,,}" == "sway" ]; then
      SWAY_XWAYLAND_FILE="/etc/sway/config.d/99-noxwayland.conf"
      if test -e $SWAY_XWAYLAND_FILE; then
        rm -f $SWAY_XWAYLAND_FILE
        echo "Xwayland for Sway has been enabled."
      else
        cp /usr$SWAY_XWAYLAND_FILE $SWAY_XWAYLAND_FILE
        chmod 644 $SWAY_XWAYLAND_FILE
        echo "Xwayland for Sway has been disabled."
      fi
    fi

# Toggle bash environment lockdown (mitigates LD_PRELOAD attacks)
toggle-bash-environment-lockdown:
    #! /bin/run0 /usr/bin/bash
    set -eou pipefail
    # The below lines fetch the minimium and maximium UIDS as configured in /etc/login.defs. Any UIDs within this change are true user ids
    # rather than system agents, and therefore should be locked down. The user_string variable uses this fetched UID range to find all 
    # existing users and their home directory along with formatting this data for later use. The IFS line simple converts this data data 
    # into a bash array.
    uid_min=$(grep -Po '^\s*UID_MIN\s+\K\d+' /etc/login.defs)
    uid_max=$(grep -Po '^\s*UID_MAX\s+\K\d+' /etc/login.defs)
    user_string=$(getent passwd | awk -F':' -v max="$uid_max" -v min="$uid_min" 'max >= $3 && $3 >= min {print $1}' | tr '\n' ',' | sed 's/,*$//')
    IFS=',' read -ra user_list <<< "$user_string"
    # $SUDO_USER is the user who started the script instead of whichever authorized it via polkit or the root home. From there this 
    # $USER_HOME uses getent to lookup their home directory to later check if they have an existing .bashrc file.
    USER_HOME=$(getent passwd $SUDO_USER | cut -d: -f6)
    if lsattr "$USER_HOME/.bashrc" 2>/dev/null | awk '{print $1}' | grep -q 'i'; then
      pending_status="unlocked"
    else
      pending_status="locked"
    fi
    echo "${b}WARNING${n} This will overwrite your ~/.bashrc, ~/.bash_profile, ~/.config/bash-completion, ~/.profile, ~/.bash_logout, ~/.bash_login, ~/.bashrc.d/, and ~/.config/environment.d/"
    echo "This is needed to ensure the mitigation is effective."
    echo ".bashrc, .bash_profile, and more will be ""${b}""$pending_status""${n}""."
    echo "Do you understand?"
    echo "Please type in \"YES I UNDERSTAND\" and press enter"
    read -r ACCEPT
    if [ "$ACCEPT" != "YES I UNDERSTAND" ]; then
        exit
    fi
    echo "Do you want this change to apply to ""${b}""all""${n}"" users (""${user_list[@]}"")? [y/N]"
    echo "Otherwise, it will only apply to the user who launched this script ($SUDO_USER)."
    read -r REPLY
    # Note this way the default if you press enter is to only effect the user who launched this script
    if [[ "$REPLY" != [yY]* ]]; then
    	user_list=("$SUDO_USER")
    fi

    chattr_operator=$([ "$pending_status" == "locked" ] && echo "+i" || echo "-i")  
    for user in "${user_list[@]}"; do
    	echo "Applying for user: $user"
    	user_home=$(getent passwd "$user" | awk -F':' '{ print $6}')
    	[[ -d "$user_home" ]] || {echo "Variable \$user_home for $user is somehow empty (check your getent passwd entries); safely exiting."; exit 1;}

      BASH_ENV_FILES=(
        "$user_home/.bashrc"
        "$user_home/.bash_profile"
        "$user_home/.config/bash-completion"
        "$user_home/.profile"
        "$user_home/.bash_logout"
        "$user_home/.bash_login"
      )

      BASH_ENV_DIRS=(
        "$user_home/.bashrc.d/"
        "$user_home/.config/environment.d/"
      )

      for file in "${BASH_ENV_FILES[@]}"; do
        touch "$file"
      done

      if [ "$pending_status" == "locked" ]; then
        cp /usr/share/secureblue/templates/.bash_profile "$user_home/.bash_profile"
        cp /usr/share/secureblue/templates/.bashrc "$user_home/.bashrc"
      fi

      for dir in "${BASH_ENV_DIRS[@]}"; do
          mkdir -p "$dir"
      done

      BASH_ENV_FILES_DIRS=("${BASH_ENV_FILES[@]}" "${BASH_ENV_DIRS[@]}")

      for fs_object in "${BASH_ENV_FILES_DIRS[@]}"; do
        recursion_operator=$([ -d "$fs_object" ] && echo "-R" || echo "")  
        chattr "$chattr_operator" "$recursion_operator" "$fs_object"
      done
    done

    echo "${user_list[@]}" "$pending_status."
    echo "WARNING: until a reboot, any process with an open file descriptor will continue to have the access they had before this script was run."

# Toggle unconfined domain userns creation
toggle-unconfined-domain-userns-creation:
    #! /bin/run0 /bin/bash
    MODULE_NAME="harden_userns"

    if semodule -l | grep -q "$MODULE_NAME"; then
        echo "Module $MODULE_NAME is currently enabled. Disabling it..."
        semodule --disable="$MODULE_NAME"
        echo "Module $MODULE_NAME disabled."
    else
        echo "Module $MODULE_NAME is not currently enabled. Enabling it..."
        semodule --enable="$MODULE_NAME"
        echo "Module $MODULE_NAME enabled."
    fi

# Toggle container domain userns creation
toggle-container-domain-userns-creation:
    #! /bin/run0 /bin/bash
    MODULE_NAME="harden_container_userns"

    if semodule -l | grep -q "$MODULE_NAME"; then
        echo "Module $MODULE_NAME is currently enabled. Disabling it..."
        semodule --disable="$MODULE_NAME"
        echo "Module $MODULE_NAME disabled."
    else
        echo "Module $MODULE_NAME is not currently enabled. Enabling it..."
        semodule --enable="$MODULE_NAME"
        echo "Module $MODULE_NAME enabled."
    fi

# Toggle MAC Randomization
toggle-mac-randomization:
    #! /bin/run0 /bin/bash
    RAND_MAC_FILE="/etc/NetworkManager/conf.d/rand_mac.conf"

    if test -e $RAND_MAC_FILE; then
        rm -f $RAND_MAC_FILE
        echo "MAC randomization disabled."
        systemctl restart NetworkManager
    else
        echo "MAC randomization can be stable (persisting the same random MAC per access point across disconnects/reboots),"
        echo "or it can be randomized per-connection (every time it connects to the same access point it uses a new MAC)."
        read -p "Do you want to use per-connection Wi-Fi MAC address randomization? [y/N]" randomization_level
        randomization_level=${randomization_level:-n}

        if [ "$randomization_level" == [Yy]* ]; then
            randomization_level=random
            echo "Selected state: per-connection"
        else
            randomization_level=stable
            echo "Selected state: per-network (stable)"
        fi
        cat <<EOL > $RAND_MAC_FILE
    [device-mac-randomization]
    # "yes" is already the default for scanning
    wifi.scan-rand-mac-address=yes

    [connection-mac-randomization]
    # Generate a random MAC for each Network and associate the two permanently.
    ethernet.cloned-mac-address=stable
    wifi.cloned-mac-address=$randomization_level
    EOL
        echo "MAC randomization enabled."
        systemctl restart NetworkManager
    fi
